#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VENV_DIR="$SCRIPT_DIR/.venv"
LOG_DIR="$SCRIPT_DIR/logs"
CFG="$SCRIPT_DIR/config.json"
PID_FILE="$SCRIPT_DIR/.server.pid"
PID_FILE_PUBLIC="$SCRIPT_DIR/.server-public.pid"

_check_venv() {
    if [[ ! -f "$VENV_DIR/bin/uvicorn" ]]; then
        echo "Fehler: Virtuelle Umgebung nicht gefunden. Bitte zuerst 'openknxviewer setup' ausführen."
        exit 1
    fi
}

# Liest einen Wert aus config.json; gibt $default zurück wenn nicht gesetzt
_cfg_get() {
    local key="$1" default="$2"
    python3 - "$CFG" "$key" "$default" <<'EOF'
import json, pathlib, sys
p = pathlib.Path(sys.argv[1])
d = json.loads(p.read_text()) if p.exists() else {}
print(d.get(sys.argv[2], sys.argv[3]))
EOF
}

# Schreibt einen Integer-Wert in config.json
_cfg_set_int() {
    local key="$1" value="$2"
    python3 - "$CFG" "$key" "$value" <<'EOF'
import json, pathlib, sys
p = pathlib.Path(sys.argv[1])
d = json.loads(p.read_text()) if p.exists() else {}
d[sys.argv[2]] = int(sys.argv[3])
p.write_text(json.dumps(d, indent=2))
EOF
}

# Gibt den konfigurierten Server-Port zurück; fragt beim ersten Mal nach
_get_server_port() {
    local cfg_key="$1" default="$2" label="$3"
    local stored
    stored=$(_cfg_get "$cfg_key" "")
    if [[ -z "$stored" ]]; then
        read -r -p "${label} Port [${default}]: " input
        stored="${input:-$default}"
        _cfg_set_int "$cfg_key" "$stored"
        echo "  Port $stored in config.json gespeichert." >&2
    fi
    echo "$stored"
}

# ── setup ─────────────────────────────────────────────────────────────────────
cmd_setup() {
    echo "==> Erstelle virtuelles Environment …"
    python3 -m venv "$VENV_DIR"
    echo "==> Installiere Abhängigkeiten …"
    "$VENV_DIR/bin/pip" install --upgrade pip --quiet
    "$VENV_DIR/bin/pip" install -r "$SCRIPT_DIR/requirements.txt" --quiet
    echo ""
    echo "Fertig! Server starten mit:  ./openknxviewer start"
}

# ── start ─────────────────────────────────────────────────────────────────────
cmd_start() {
    _check_venv
    local public=false port_override=""
    local args=("$@") i=0
    while [[ $i -lt ${#args[@]} ]]; do
        case "${args[$i]}" in
            --public) public=true ;;
            --port)   i=$((i+1)); port_override="${args[$i]}" ;;
        esac
        i=$((i+1))
    done
    mkdir -p "$LOG_DIR"

    local cfg_key default label pid_file server stdout_log stderr_log
    if $public; then
        cfg_key="server_port_public"; default=8004
        label="Öffentlicher Server"; pid_file="$PID_FILE_PUBLIC"
        server="server_public:app"
        stdout_log="stdout-public.log"; stderr_log="stderr-public.log"
    else
        cfg_key="server_port"; default=8002
        label="Privater Server"; pid_file="$PID_FILE"
        server="server:app"
        stdout_log="stdout.log"; stderr_log="stderr.log"
    fi

    local port
    if [[ -n "$port_override" ]]; then
        port="$port_override"
        _cfg_set_int "$cfg_key" "$port"
    else
        port=$(_get_server_port "$cfg_key" "$default" "$label")
    fi

    if [[ -f "$pid_file" ]] && kill -0 "$(cat "$pid_file")" 2>/dev/null; then
        echo "$label läuft bereits (PID $(cat "$pid_file"), Port $port)"
        exit 0
    fi
    cd "$SCRIPT_DIR"
    "$VENV_DIR/bin/uvicorn" "$server" --host 0.0.0.0 --port "$port" \
        >>"$LOG_DIR/$stdout_log" 2>>"$LOG_DIR/$stderr_log" &
    echo $! >"$pid_file"
    echo "$label gestartet (PID $!, Port $port)"
}

# ── stop ──────────────────────────────────────────────────────────────────────
_stop_one() {
    local pid_file="$1" label="$2"
    if [[ -f "$pid_file" ]]; then
        local pid
        pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid"
            echo "$label gestoppt (PID $pid)"
        else
            echo "$label war nicht aktiv"
        fi
        rm -f "$pid_file"
    else
        echo "Kein PID-File für $label gefunden"
    fi
}

cmd_stop() {
    local public=false all=false
    for arg in "$@"; do
        [[ "$arg" == "--public" ]] && public=true
        [[ "$arg" == "--all"    ]] && all=true
    done
    if $all; then
        _stop_one "$PID_FILE"        "Privater Server"
        _stop_one "$PID_FILE_PUBLIC" "Öffentlicher Server"
    elif $public; then
        _stop_one "$PID_FILE_PUBLIC" "Öffentlicher Server"
    else
        _stop_one "$PID_FILE" "Privater Server"
    fi
}

# ── status ────────────────────────────────────────────────────────────────────
_status_one() {
    local pid_file="$1" label="$2" port="$3" is_private="${4:-false}"
    if [[ -f "$pid_file" ]] && kill -0 "$(cat "$pid_file")" 2>/dev/null; then
        printf "%-24s läuft   (PID %s, Port %s)\n" "$label:" "$(cat "$pid_file")" "$port"
        if [[ "$is_private" == "true" ]] && command -v curl &>/dev/null; then
            local gw
            gw=$(curl -sf "http://localhost:${port}/api/gateway" 2>/dev/null || true)
            if [[ -n "$gw" ]]; then
                python3 - "$gw" <<'EOF'
import json, sys
d = json.loads(sys.argv[1])
ip   = d.get('ip', '?')
port = d.get('port', '?')
ok   = 'verbunden' if d.get('connected') else 'nicht verbunden'
lang = d.get('language', '?')
print(f'  Gateway:               {ip}:{port} — {ok}  [{lang}]')
EOF
            fi
        fi
    else
        printf "%-24s gestoppt\n" "$label:"
    fi
}

cmd_status() {
    local port_priv port_pub
    port_priv=$(_cfg_get "server_port"        "8002")
    port_pub=$( _cfg_get "server_port_public" "8004")
    _status_one "$PID_FILE"        "Privater Server"     "$port_priv" "true"
    _status_one "$PID_FILE_PUBLIC" "Öffentlicher Server" "$port_pub"  "false"
}

# ── logs ──────────────────────────────────────────────────────────────────────
cmd_logs() {
    local lines=50 follow=false
    local args=("$@") i=0
    while [[ $i -lt ${#args[@]} ]]; do
        case "${args[$i]}" in
            --lines|-n) i=$((i+1)); lines="${args[$i]}" ;;
            --follow|-f) follow=true ;;
        esac
        i=$((i+1))
    done
    local log_file="$LOG_DIR/knx_bus.log"
    if [[ ! -f "$log_file" ]]; then
        echo "Keine Logdatei vorhanden: $log_file"
        exit 1
    fi
    if $follow; then
        tail -n "$lines" -f "$log_file"
    else
        tail -n "$lines" "$log_file"
    fi
}

# ── gateway ───────────────────────────────────────────────────────────────────
cmd_gateway() {
    local ip="" gw_port="" lang=""
    local args=("$@") i=0
    while [[ $i -lt ${#args[@]} ]]; do
        case "${args[$i]}" in
            --ip)       i=$((i+1)); ip="${args[$i]}" ;;
            --port)     i=$((i+1)); gw_port="${args[$i]}" ;;
            --language) i=$((i+1)); lang="${args[$i]}" ;;
        esac
        i=$((i+1))
    done

    if [[ -z "$ip" && -z "$gw_port" && -z "$lang" ]]; then
        if [[ -f "$CFG" ]]; then
            python3 - "$CFG" <<'EOF'
import json, sys
d = json.load(open(sys.argv[1]))
print(f"Gateway-IP:    {d.get('gateway_ip','(nicht gesetzt)')}")
print(f"Gateway-Port:  {d.get('gateway_port', 3671)}")
print(f"Sprache:       {d.get('language', 'de-DE')}")
print(f"Server-Port:   {d.get('server_port', 8002)}")
print(f"Public-Port:   {d.get('server_port_public', 8004)}")
EOF
        else
            echo "config.json nicht gefunden"
        fi
        return
    fi

    # Server läuft → API verwenden
    local srv_port
    srv_port=$(_cfg_get "server_port" "8002")
    if [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null && command -v curl &>/dev/null; then
        local current
        current=$(curl -sf "http://localhost:${srv_port}/api/gateway" 2>/dev/null || true)
        if [[ -n "$current" ]]; then
            python3 - "$current" "$ip" "$gw_port" "$lang" <<'EOF'
import json, sys, urllib.request
d    = json.loads(sys.argv[1])
ip   = sys.argv[2] if sys.argv[2] else d['ip']
port = int(sys.argv[3]) if sys.argv[3] else d['port']
lang = sys.argv[4] if sys.argv[4] else d.get('language', 'de-DE')
payload = json.dumps({'ip': ip, 'port': port, 'language': lang}).encode()
req = urllib.request.Request(
    f"http://localhost:{d.get('port', 8002)}/api/gateway",
    data=payload, headers={'Content-Type': 'application/json'}, method='POST')
urllib.request.urlopen(req)
print(f'Gateway aktualisiert (via API): {ip}:{port}, Sprache: {lang}')
EOF
            return
        fi
    fi

    # Server gestoppt → config.json direkt schreiben
    python3 - "$CFG" "$ip" "$gw_port" "$lang" <<'EOF'
import json, pathlib, sys
p    = pathlib.Path(sys.argv[1])
d    = json.loads(p.read_text()) if p.exists() else {}
ip, port, lang = sys.argv[2], sys.argv[3], sys.argv[4]
if ip:   d['gateway_ip']   = ip
if port: d['gateway_port'] = int(port)
if lang: d['language']     = lang
p.write_text(json.dumps(d, indent=2))
print(f"Gateway gespeichert: {d.get('gateway_ip')}:{d.get('gateway_port')}, Sprache: {d.get('language')}")
EOF
}

# ── autostart (macOS LaunchAgent) ─────────────────────────────────────────────
cmd_autostart() {
    if [[ "$(uname)" != "Darwin" ]]; then
        echo "Autostart wird nur unter macOS unterstützt."
        exit 1
    fi
    local public=false remove=false
    for arg in "$@"; do
        [[ "$arg" == "--public" ]] && public=true
        [[ "$arg" == "--remove" ]] && remove=true
    done

    local label cfg_key default server stdout_log stderr_log
    if $public; then
        label="com.knxproject-viewer-public"
        cfg_key="server_port_public"; default=8004
        server="server_public:app"
        stdout_log="stdout-public.log"; stderr_log="stderr-public.log"
    else
        label="com.knxproject-viewer"
        cfg_key="server_port"; default=8002
        server="server:app"
        stdout_log="stdout.log"; stderr_log="stderr.log"
    fi
    local plist="$HOME/Library/LaunchAgents/${label}.plist"

    if $remove; then
        if [[ -f "$plist" ]]; then
            launchctl unload -w "$plist" 2>/dev/null || true
            rm "$plist"
            echo "Autostart entfernt: $plist"
        else
            echo "Kein Autostart gefunden: $plist"
        fi
        return
    fi

    _check_venv
    local port
    port=$(_cfg_get "$cfg_key" "$default")
    mkdir -p "$LOG_DIR"
    cat >"$plist" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>             <string>${label}</string>
    <key>ProgramArguments</key>
    <array>
        <string>${VENV_DIR}/bin/uvicorn</string>
        <string>${server}</string>
        <string>--host</string>  <string>0.0.0.0</string>
        <string>--port</string>  <string>${port}</string>
    </array>
    <key>RunAtLoad</key>         <true/>
    <key>KeepAlive</key>         <true/>
    <key>WorkingDirectory</key>  <string>${SCRIPT_DIR}</string>
    <key>StandardOutPath</key>   <string>${LOG_DIR}/${stdout_log}</string>
    <key>StandardErrorPath</key> <string>${LOG_DIR}/${stderr_log}</string>
</dict>
</plist>
EOF
    launchctl unload "$plist" 2>/dev/null || true
    launchctl load -w "$plist"
    echo "Autostart installiert: $plist"
    echo "Server startet bei jedem Login auf Port $port."
    echo "Logs: $LOG_DIR/"
}

# ── update ────────────────────────────────────────────────────────────────────
cmd_update() {
    _check_venv
    echo "==> Aktualisiere Abhängigkeiten …"
    "$VENV_DIR/bin/pip" install --upgrade pip --quiet
    "$VENV_DIR/bin/pip" install --upgrade -r "$SCRIPT_DIR/requirements.txt" --quiet
    echo ""
    echo "Installierte Versionen:"
    "$VENV_DIR/bin/pip" show xknxproject xknx fastapi uvicorn 2>/dev/null \
        | grep -E "^(Name|Version):" | paste - - \
        | awk '{printf "  %-20s %s\n", $2, $4}'
}

# ── usage ─────────────────────────────────────────────────────────────────────
usage() {
    echo "Verwendung: openknxviewer <Befehl> [Optionen]"
    echo ""
    echo "  setup                                       Umgebung erstellen & Pakete installieren"
    echo "  start  [--public] [--port N]                Server starten (fragt Port beim ersten Mal)"
    echo "  stop   [--public | --all]                   Server stoppen"
    echo "  status                                      Server- und Gateway-Status anzeigen"
    echo "  logs   [--lines N] [--follow]               Bus-Log anzeigen"
    echo "  gateway                                     Konfiguration anzeigen"
    echo "  gateway --ip X [--port Y] [--language L]    KNX-Gateway konfigurieren"
    echo "  update                                      Alle Pakete aktualisieren"
    echo "  autostart          [--public]               macOS LaunchAgent installieren"
    echo "  autostart --remove [--public]               macOS LaunchAgent entfernen"
}

# ── dispatch ──────────────────────────────────────────────────────────────────
case "${1:-}" in
    setup)     shift; cmd_setup     "$@" ;;
    start)     shift; cmd_start     "$@" ;;
    stop)      shift; cmd_stop      "$@" ;;
    status)    shift; cmd_status    "$@" ;;
    logs)      shift; cmd_logs      "$@" ;;
    gateway)   shift; cmd_gateway   "$@" ;;
    update)    shift; cmd_update    "$@" ;;
    autostart) shift; cmd_autostart "$@" ;;
    *)         usage; exit 1 ;;
esac
